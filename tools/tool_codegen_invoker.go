package main

import (
	"fmt"
	"log"
	"os"

	// Assuming 'codegen' is in the parent directory or Go module path is set up correctly.
	// For a local relative path, it might be "../codegen" if main.go is in a cmd dir,
	// or if the module is setup, it would be "<module_name>/codegen".
	// For this example, let's assume it's accessible as "<your_module_name>/codegen".
	// If running directly from within the tools folder and codegen is ../codegen:
	// import "../codegen"
	// However, for a typical Go project structure, you'd use module paths.
	// Let's use a placeholder module name for now: "smolcode/codegen"
	// This will need to be adjusted to your actual module name or relative path.
	"smolcode/codegen" // Placeholder: Replace smolcode with your actual go module name if needed
)

func main() {
	apiKey := os.Getenv("INCEPTION_API_KEY")
	if apiKey == "" {
		log.Fatal("Error: INCEPTION_API_KEY environment variable not set.")
	}

	// Initialize the generator
	generator := codegen.New(apiKey)
	fmt.Println("Generator initialized.")

	// Prepare sample instruction and existing files
	instruction := "Create a simple Go program that prints Hello, World."

	// No existing files for this simple example, but you could add some:
	// existingFiles := []codegen.File{
	// 	{Path: "existing.go", Contents: []byte("package main\n\n// Some existing code")},
	// }
	existingFiles := []codegen.File{} // Empty slice

	fmt.Printf("Instruction: %s\n", instruction)
	if len(existingFiles) > 0 {
		fmt.Println("Existing files provided:")
		for _, f := range existingFiles {
			fmt.Printf("- %s\n", f.Path)
		}
	} else {
		fmt.Println("No existing files provided.")
	}

	// Call GenerateCode
	fmt.Println("Calling GenerateCode...")
	generatedFiles, err := generator.GenerateCode(instruction, existingFiles)
	if err != nil {
		log.Fatalf("Error calling GenerateCode: %v", err)
	}

	fmt.Printf("GenerateCode returned %d file(s).\n", len(generatedFiles))
	for _, gf := range generatedFiles {
		fmt.Printf("- Generated file path (from API response): %s\n", gf.Path)
		// fmt.Printf("  Contents:\n%s\n", string(gf.Contents)) // Uncomment to see contents
	}

	if len(generatedFiles) == 0 {
		fmt.Println("No files were generated by the API. Nothing to write.")
		return
	}

	// Call Write
	// IMPORTANT: The paths in `generatedFiles` come from the API.
	// For this tool, we might want to prefix them with a specific output directory, e.g., "./generated_output/"
	// For now, it will attempt to write them relative to where this tool is run.
	// Make sure the paths are safe and intended before writing.
	// Example: to write into an 'output' subdirectory:
	// outputDir := "./output_tool_codegen"
	// if err := os.MkdirAll(outputDir, 0755); err != nil {
	// 	log.Fatalf("Failed to create output directory %s: %v", outputDir, err)
	// }
	// for i := range generatedFiles {
	// 	generatedFiles[i].Path = filepath.Join(outputDir, generatedFiles[i].Path)
	// }

	fmt.Println("Calling Write to save generated files...")
	err = generator.Write(generatedFiles)
	if err != nil {
		log.Fatalf("Error calling Write: %v", err)
	}

	fmt.Println("Files written successfully!")
	for _, gf := range generatedFiles {
		fmt.Printf("- Wrote: %s\n", gf.Path)
	}

	fmt.Println("\nTool execution finished.")
}
